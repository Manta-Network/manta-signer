// @ts-nocheck
import * as BN from 'bn.js';
import { SimulatedLedgerState } from '../classes/simulatedLedgerState';
import { ClientAsset } from '../classes/clientAsset';
import { SignerParamGen } from './signerParamGen';
import { SignerClient } from './signerClient';
import { BrowserAssetStore } from '../store/assetStore/browserAssetStore';
import { BrowserBlockchainStore } from '../store/blockchainStore/browserBlockchainStore';
import { BrowserAddressStore } from '../store/addressStore/browserAddressStore';
import { BlockchainNodeClient } from './blockchainNodeClient';
import { JsonAddressStore } from '../store/addressStore/jsonAddressStore';
import { JsonAssetStore } from '../store/assetStore/jsonAssetStore';
import { JsonBlockchainStore } from '../store/blockchainStore/jsonBlockchainStore';

export class SignerInterface {
  constructor(api, config) {
    this.api = api;
    this.ledgerState = new SimulatedLedgerState(api);
    this.signerClient = new SignerClient(api, config.signerUrl);
    this.signerParamGen = new SignerParamGen(api);
    this.blockchainNodeClient = new BlockchainNodeClient(api);

    if (config.isInBrowser) {
      this.addressStore = new BrowserAddressStore(
        config.bip44CoinTypeId,
        config.baseStorageKey
      );
      this.assetStore = new BrowserAssetStore(api, config.baseStorageKey);
      this.blockchainStore = new BrowserBlockchainStore(config.baseStorageKey);
    } else {
      this.addressStore = new JsonAddressStore(
        config.bip44CoinTypeId,
        config.baseStorageKey
      );
      this.assetStore = new JsonAssetStore(api, config.baseStorageKey);
      this.blockchainStore = new JsonBlockchainStore(config.baseStorageKey);
    }
  }

  // To be run after a transaction generated by SignerInterface is published on
  // chain, before generating further transactions
  cleanupTxSuccess() {
    this.addressStore.commitInternalAddresses();
    // reset simulated ledger state now that simulated changes are irrelevant
    this.ledgerState = new SimulatedLedgerState(this.api);
  }

  // To be run after a transaction generated by SignerInterface fails
  // (on or off chain), before generating further transactions
  cleanupTxFailure() {
    this.addressStore.rollBackInternalAddresses();
    // reset ledger state now that simulated changes are on chain
    this.ledgerState = new SimulatedLedgerState(this.api);
  }

  // Returns the version of the connected instance of Manta Signer
  async getSignerVersion() {
    return await this.signerClient.getSignerVersion();
  }

  // Returns true if Manta Signer can be pinged and false otherwise
  async signerIsConnected() {
    const version = await this.getSignerVersion();
    return !!version;
  }

  // Generates a list of transaction that, when executed in sequence, accomplish
  // a private transfer to the given receivingAddress
  async buildExternalPrivateTransferTxs(receivingAddress, coinSelection) {
    const mintZeroCoinTxs = await this._maybeBuildMintZeroCoinTxs(
      coinSelection
    );

    // build params
    const batchParams = await this._buildPrivateTransferBatchParams(
      coinSelection,
      receivingAddress
    );

    // build transaction data
    const privateTransferDataList =
      await this.signerClient.requestGeneratePrivateTransferData(batchParams);

    // build transactions
    const transactions = privateTransferDataList.map((privateTransferData) =>
      this.api.tx.mantaPay.privateTransfer(privateTransferData)
    );
    mintZeroCoinTxs.forEach((mintZeroCointTx) =>
      transactions.unshift(mintZeroCointTx)
    );
    return transactions;
  }

  // Generates a list of transaction that, when executed in sequence, accomplishes
  // a reclaim of private assets owned by the connected instance of Manta Signer
  // to some public address
  async buildReclaimTxs(coinSelection) {
    const mintZeroCoinTxs = await this._maybeBuildMintZeroCoinTxs(
      coinSelection
    );

    // build params
    const batchParams = await this._buildReclaimBatchParams(coinSelection);

    // build transaction data
    const reclaimData = await this.signerClient.requestGenerateReclaimData(
      batchParams
    );

    // build transactions
    const privateTransfersTransactions =
      reclaimData.private_transfer_data_list.map((privateTransferData) =>
        this.api.tx.mantaPay.privateTransfer(privateTransferData)
      );
    const reclaimTransaction = this.api.tx.mantaPay.reclaim(
      reclaimData.reclaim_data
    );
    const transactions = [...privateTransfersTransactions, reclaimTransaction];
    mintZeroCoinTxs.forEach((mintZeroCointTx) =>
      transactions.unshift(mintZeroCointTx)
    );

    return transactions;
  }

  // Generates a single transaction to mint a private asset of the given id / value,
  // to be owned by the connected instance of Manta Signer
  async buildMintTx(assetId, valueAtomicUnits) {
    await this._generateNextInternalAddress();
    const mintAssetkeypath = this.addressStore.getCurrentInternalKeypath();
    const mintAsset = new ClientAsset(
      assetId,
      valueAtomicUnits,
      mintAssetkeypath
    );
    const mintParams = this.signerParamGen.generateMintParams(mintAsset);
    const mintData = await this.signerClient.generateMintData(mintParams);
    const mintTx = this.api.tx.mantaPay.mintPrivateAsset(mintData);
    return mintTx;
  }

  // Generates the next external address in the standard BIP42 external keypath
  // belonging to connected instance of Manta Signer. External addresses should
  // only be used for receiving external payments, e.g. as the addresses
  // displayed in Manta Web App
  async generateNextExternalAddress() {
    const keypath = this.addressStore.getNextExternalKeypath();
    const params = this.signerParamGen.generateAddressParams(keypath);
    const address = await this.signerClient.deriveShieldedAddress(params);
    this.addressStore.saveExternalAddress(address);
    return address;
  }

  // Returns all assets currently owned by the connected instance of Manta Signer
  async recoverAccount() {
    // Collect parameters from on chain
    const voidNumbers = await this.blockchainNodeClient.getAllVoidNumbers();
    const { newUTXOs, newEncryptedNotes, utxoSet } =
      await this.blockchainNodeClient.getNewUTXOsAndEncryptedNotes(
        this.blockchainStore.loadUTXOSet()
      );
    const params = this.signerParamGen.generateRecoverAccountParams(
      newUTXOs,
      newEncryptedNotes,
      voidNumbers
    );

    // Get newly received assets from manta signer and add to storage
    const newPrivateAssets = await this.signerClient.recoverAccount(params);
    this.assetStore.addPrivateAssets(newPrivateAssets);
    this.blockchainStore.saveUTXOSet(utxoSet);

    // Get rid of assets we have spend since last refresh
    this._purgeSpentAssets(voidNumbers);

    return this.assetStore.loadPrivateAssets();
  }

  // Resets all persistent state that signer interface keeps
  resetStorage() {
    this.assetStore.reset();
    this.addressStore.reset();
    this.blockchainStore.reset();
  }

  // Removes assets from storage if their void number has been revealed on chain
  _purgeSpentAssets(voidNumbers) {
    const voidNumbersSet = new Set();
    voidNumbers.forEach((voidNumber) => {
      const voidNumberString = voidNumber.join(',');
      voidNumbersSet.add(voidNumberString);
    });
    const privateAssets = this.assetStore.loadPrivateAssets();
    const unspentAssets = privateAssets.filter(
      (asset) => !voidNumbersSet.has(asset.voidNumber.join(','))
    );
    this.assetStore.savePrivateAssets(unspentAssets);
  }

  // Builds up to two transaction to mint a private asset of zero value, but
  // only if this zero asset is required to complete a transaction, i.e. if the
  // coin selection only contains contains less than two coins
  async _maybeBuildMintZeroCoinTxs(coinSelection) {
    const mintZeroCoinTxs = [];
    const numberOfZeroCoinsRequired = coinSelection.numberOfZeroCoinsRequired();
    for (let i = 0; i < numberOfZeroCoinsRequired; i++) {
      const mintZeroCoinTx = await this._buildMintZeroCoinTx(coinSelection);
      mintZeroCoinTxs.push(mintZeroCoinTx);
    }
    return mintZeroCoinTxs;
  }

  // Builds a single transaction that mints a coin of zero value
  async _buildMintZeroCoinTx(coinSelection) {
    const zeroCoinAsset = await this._generateInternalAsset(
      coinSelection.assetId,
      new BN(0)
    );
    coinSelection.coins.unshift(zeroCoinAsset);
    this.ledgerState.addOffChainAsset(zeroCoinAsset);
    const zeroCoinParams =
      this.signerParamGen.generateMintParams(zeroCoinAsset);

    const mintZeroCoinData = await this.signerClient.generateMintData(
      zeroCoinParams
    );
    return this.api.tx.mantaPay.mintPrivateAsset(mintZeroCoinData);
  }

  // Builds the parameters required by Manta Signer to build a 'logical' private transfer
  async _buildPrivateTransferBatchParams(coinSelection, receivingAddress) {
    const { internalTransferParamsList, accumulatorInput } =
      await this._buildInternalTransferParamsList(coinSelection);
    const terminalPrivateTransferParams =
      await this._buildTerminalPrivateTransferParams(
        coinSelection,
        accumulatorInput
      );
    const transferParamsList = [
      ...internalTransferParamsList,
      terminalPrivateTransferParams
    ];
    return await this.signerParamGen.generatePrivateTransferBatchParams(
      coinSelection.assetId,
      receivingAddress,
      transferParamsList
    );
  }

  // Builds the parameters required by Manta Signer to build a 'logical' reclaim transaction
  async _buildReclaimBatchParams(coinSelection) {
    const { internalTransferParamsList, accumulatorInput } =
      await this._buildInternalTransferParamsList(coinSelection);
    const reclaimParams = await this._buildTerminalReclaimParams(
      coinSelection,
      accumulatorInput
    );
    return await this.signerParamGen.generateReclaimBatchParams(
      internalTransferParamsList,
      reclaimParams
    );
  }

  // Builds the parameters required by Manta Signer to build 'setup' transactions
  // and accumulate assets into exacly two inputs within the user's own wallet,
  // in preparation for some final transaction
  async _buildInternalTransferParamsList(coinSelection) {
    const internalTransferParamsList = [];
    let accumulatorInput;
    for (let i = 1; i < coinSelection.coins.length - 1; i++) {
      const inputAsset1 = accumulatorInput || coinSelection.coins[0];
      const inputAsset2 = coinSelection.coins[i];
      await this._setShard(inputAsset1);
      await this._setShard(inputAsset2);
      const totalValueAtomicUnits = inputAsset2.valueAtomicUnits.add(
        inputAsset1.valueAtomicUnits
      );
      const changeOutput = await this._generateInternalAsset(
        coinSelection.assetId,
        new BN(0)
      );
      const accumulatorOutput = await this._generateInternalAsset(
        coinSelection.assetId,
        totalValueAtomicUnits
      );
      this.ledgerState.addOffChainAsset(accumulatorOutput);
      this.ledgerState.addOffChainAsset(changeOutput);

      const params = await this.signerParamGen.generatePrivateTransferParams(
        inputAsset1,
        inputAsset2,
        changeOutput,
        accumulatorOutput
      );
      internalTransferParamsList.push(params);
      accumulatorInput = accumulatorOutput;
    }
    return { internalTransferParamsList, accumulatorInput };
  }

  // Builds the parameters required by Manta Signer to build the final private
  // transfer transaction, which finally sends assets accumulated within a
  // user's own wallet to some external address
  async _buildTerminalPrivateTransferParams(coinSelection, accumulatorInput) {
    const inputAsset1 = accumulatorInput || coinSelection.secondLast();
    const inputAsset2 = coinSelection.last();

    await this._setShard(inputAsset1);
    await this._setShard(inputAsset2);

    const changeOutput = await this._generateInternalAsset(
      coinSelection.assetId,
      coinSelection.changeValueAtomicUnits
    );
    const nonChangeOutput = await ClientAsset.newExternalOutput(
      coinSelection.assetId,
      coinSelection.targetValueAtomicUnits
    );

    const params = await this.signerParamGen.generatePrivateTransferParams(
      inputAsset1,
      inputAsset2,
      changeOutput,
      nonChangeOutput
    );
    return params;
  }

  // Builds the parameters required by Manta Signer to build the final reclaim
  // transaction, which finally redeems private assets accumulated within a
  // user's own private wallet to some public address
  async _buildTerminalReclaimParams(coinSelection, accumulatorInput) {
    const inputAsset1 = accumulatorInput || coinSelection.secondLast();
    const inputAsset2 = coinSelection.last();

    await this._setShard(inputAsset1);
    await this._setShard(inputAsset2);

    const changeOutput = await this._generateInternalAsset(
      coinSelection.assetId,
      coinSelection.changeValueAtomicUnits
    );
    const params = await this.signerParamGen.generateReclaimParams(
      inputAsset1,
      inputAsset2,
      changeOutput
    );
    return params;
  }

  // Generates the next address in the standard BIP42 internal keypath
  // belonging to connected instance of Manta Signer. Internal addresses should
  // only receive change outputs and freshly minted assets generated by the user's
  // own wallet, and should never appear in a UI
  async _generateNextInternalAddress() {
    const keypath = this.addressStore.getNextInternalKeypath();
    const params = this.signerParamGen.generateAddressParams(keypath);
    const address = await this.signerClient.deriveShieldedAddress(params);
    this.addressStore.saveInternalAddress(address);
  }

  // Generates an 'off chain' assets belonging to the connected instance of Manta Signer
  async _generateInternalAsset(assetId, value) {
    await this._generateNextInternalAddress();
    const keypath = this.addressStore.getCurrentInternalKeypath();
    const params = this.signerParamGen.generateAssetParams(
      assetId,
      keypath,
      value
    );
    const asset = await this.signerClient.generateAsset(params);
    return ClientAsset.fromSignerAsset(asset);
  }

  // Sets the shard for some asset to incorporate both current on-chain state and
  // simulated future ledger state
  async _setShard(asset) {
    const shard = await this.ledgerState.getShard(asset);
    asset.setShard(shard);
  }
}
